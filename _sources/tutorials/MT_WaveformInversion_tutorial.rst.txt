
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/MT_WaveformInversion_tutorial.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_MT_WaveformInversion_tutorial.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_MT_WaveformInversion_tutorial.py:


Waveform-based Moment Tensor Inversion - Multicomponent
========================================================
This is a follow-up of the Amplitude-based Moment Tensor Inversion tutorial. In this tutorial, we will extend the
MT inversion algorithm to work directly with waveforms instead of picked amplitudes. By avoiding any picking,
this method can determine the moment tensor of a microseismic source when the source location is not known a-prior.
As such, it can be considered a joint location and MT inversion algorithm.

We will start once again from the far-field particle velocity expression from a moment tensor source in a homogeneous full space
(from eq. 4.29, Aki and Richards) - see the Amplitude-based Moment Tensor Inversion tutorial for more details.

However, in comparison to the Amplitude-Based Moment Tensor Inversion tutorial, in this waveform-based approach we
assume a distributed source within a subsurface area of interest and use the following integral relation to reconstruct
the surface data:

.. math::
        v_1^P(\mathbf{x_r}, t) =
        w(t) * \int\limits_V G_{pq}(\mathbf{x_r}, \mathbf{x}, t) M_{pq}(\mathbf{x})\,\mathrm{d}\mathbf{x}

where :math:`M_{pq}` with :math:`p,q=1,2,3` are the so-called MT kernels and :math:`G_{pq}` are the so-called
Green's functions, whose high-frequency approximation can be written as:

.. math::
    G_{pq}(\mathbf{x_r}, \mathbf{x}, \omega) = a_{pq}(\mathbf{x_r}, \mathbf{x})
        e^{j \omega t(\mathbf{x_r}, \mathbf{x})}

Here :math:`a_{pq}` with :math:`p,q=1,2,3` represent the same coefficients used in the Amplitude-based Moment Tensor
Inversion tutorial.

To summarize, we will apply the following workflow:

    - Load model and data;
    - Compute the traveltimes & ray angles
    - Compute the Greens functions for the subsurface area of interest
    - Define the Kirchhoff-MT operator
    - Jointly solve for the location and MT with a least-squares solver

*Assumptions*: for now, the MTWI procedure assumes a homogeneous velocity model.

.. GENERATED FROM PYTHON SOURCE LINES 41-55

.. code-block:: Python


    import os
    import matplotlib.pyplot as plt

    import fracspy

    from pylops.utils.wavelets import ricker
    from fracspy.utils.sofiutils import read_seis
    from fracspy.modelling.kirchhoff import Kirchhoff
    from fracspy.mtsolvers.mtwi import *
    from fracspy.mtsolvers.homo_mti import collect_source_angles, multicomp_Greens_Pwave
    from fracspy.mtsolvers.mtutils import get_mt_computation_dict, get_mt_at_loc, expected_sloc_from_mtwi









.. GENERATED FROM PYTHON SOURCE LINES 56-64

Load model and seismic data
---------------------------
For this example, we will use a toy homogenous model with a gridded surface
receiver array. The data are modelled using the
`SOFI3D <https://gitlab.kit.edu/kit/gpi/ag/software/sofi3d>`_
Finite Difference modelling software. The model is the same that we have used
in the FD modelling to generate the data. As such, it contains additional
boundaries, which we need to remove prior to performing localisation.

.. GENERATED FROM PYTHON SOURCE LINES 64-113

.. code-block:: Python


    # Directory containing input data
    input_dir = '../data/pyfrac_SOFIModelling'

    # Model parameters
    abs_bounds = 30
    dx = dy = dz = 5
    nx = 112
    ny = 128
    nz = 120

    # Modelling parameters
    dt = 1e-3  # SOFI3D Time sampling rate
    t_shift = 167  # Time shift required to align FD data to zero time for Kirchhoff operators
    tdur = 500  # Recording duration

    # Load model
    mod_w_bounds = np.fromfile(os.path.join(input_dir,'inputs',
                                            'models',
                                            'Homogeneous_xyz.vp'),
                               dtype='float32').reshape([nx, ny, nz])

    # Load receiver geometry
    recs_xzy = np.loadtxt(os.path.join(input_dir,'inputs',
                                       'griddedarray_xzy_20m.dat')).T
    nr = recs_xzy.shape[1]


    # Load seismic data (note that Vz is Vy given the SOFI convention)
    expname = 'MT-90-90-180_Homogeneous_griddedarray'

    vx = read_seis(os.path.join(input_dir, 'outputs', 'su', '%s_vx.txt' % expname), nr=nr)
    vy = read_seis(os.path.join(input_dir, 'outputs', 'su', '%s_vz.txt' % expname), nr=nr)
    vz = read_seis(os.path.join(input_dir, 'outputs', 'su', '%s_vy.txt' % expname), nr=nr)

    efd_scaler = np.max(abs(vz))    # Scaler to make data more friendly
    vx = vx[:, t_shift:t_shift + tdur] / efd_scaler
    vy = vy[:, t_shift:t_shift + tdur] / efd_scaler
    vz = vz[:, t_shift:t_shift + tdur] / efd_scaler

    # Combine into a single array
    FD_data = np.array([vx, vy, vz])

    # Remove absorbing boundaries for both the model and receiver coordinates
    mod = mod_w_bounds[abs_bounds:-abs_bounds, abs_bounds:-abs_bounds, :-abs_bounds] # z has free surface
    nx, ny, nz = mod.shape
    x, y, z = np.arange(nx)*dx, np.arange(ny)*dy, np.arange(nz)*dz
    recs = np.array([recs_xzy[0]-(abs_bounds*dx), recs_xzy[2]-(abs_bounds*dx), recs_xzy[1]])








.. GENERATED FROM PYTHON SOURCE LINES 114-117

Let's now double-check that the data has been loaded correctly. Observe the
changes in polarity across the traces, this is the information that we
utilise to determine the Moment Tensor.

.. GENERATED FROM PYTHON SOURCE LINES 117-124

.. code-block:: Python


    fig, axs = plt.subplots(3, 1,figsize=[10, 8])
    axs[0].imshow(vx.T, aspect='auto',cmap='binary_r')
    axs[1].imshow(vy.T, aspect='auto',cmap='binary_r')
    axs[2].imshow(vz.T, aspect='auto',cmap='binary_r')
    plt.tight_layout()




.. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_001.png
   :alt: MT WaveformInversion tutorial
   :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 125-130

Create modelling operator
-------------------------
First, we will define a Ricker wavelet with
peak frequency of 20Hz. This is the same wavelet that we used in modelling;
in real applications, this will need to be estimated from the data.

.. GENERATED FROM PYTHON SOURCE LINES 130-142

.. code-block:: Python


    nt = vz.shape[1]
    t = np.arange(nt)*dt
    wav, wavt, wavc = ricker(t[:81], f0=20)

    fig, ax = plt.subplots(figsize=(10, 2))
    ax.plot(wavt, wav, 'k', lw=2)
    ax.set_xlabel('t [s]')
    ax.set_title('Wavelet')
    ax.grid('on')
    plt.tight_layout()




.. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_002.png
   :alt: Wavelet
   :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 143-145

Second, we compute the traveltimes and ray angles to be used to create the
Green's functions.

.. GENERATED FROM PYTHON SOURCE LINES 145-159

.. code-block:: Python


    # Traveltime terms
    trav = Kirchhoff._traveltime_table(z,
                                       x,
                                       y=y,
                                       recs=recs,
                                       vel=mod,
                                       mode='eikonal')

    TTT_full = trav.reshape(nx,ny,nz,nr).transpose([3, 0, 1, 2])

    # Amplitude terms
    gamma_sourceangles, dist_table = collect_source_angles(x,y,z, reclocs=recs, nc=3)








.. GENERATED FROM PYTHON SOURCE LINES 160-164

And we can now compute the Green's functions. We will define an area of
interest where we expect the source to be located. In fact, whilst in practice
one could consider the entire subsurface, this comes with a computational and
storage burden for the Green's functions.

.. GENERATED FROM PYTHON SOURCE LINES 164-192

.. code-block:: Python


    hwin_nx_aoi, hwin_ny_aoi, hwin_nz_aoi = 15, 13, 11  # half window lengths in x, y, z
    winc_x, winc_y, winc_z = nx//2, ny//2, 2*nz//3  # Center points of the area of interest

    # Defining area of interest
    xsi, xfi = winc_x-hwin_nx_aoi, winc_x+hwin_nx_aoi+1   # start/end index of x-region of interest
    ysi, yfi = winc_y-hwin_ny_aoi, winc_y+hwin_ny_aoi+1   # start/end index of y-region of interest
    zsi, zfi = winc_z-hwin_nz_aoi, winc_z+hwin_nz_aoi+1   # start/end index of z-region of interest

    # Parameters only for the area of interest
    gamma_sourceangles_aoi = gamma_sourceangles[:, :, xsi:xfi, ysi:yfi, zsi:zfi]
    dist_table_aoi = dist_table[:, xsi:xfi, ysi:yfi, zsi:zfi]
    tt_table_aoi = TTT_full[:, xsi:xfi, ysi:yfi, zsi:zfi]
    nr, nx_aoi, ny_aoi, nz_aoi = tt_table_aoi.shape

    # This keeps everything nice and clean in the later G compute
    MT_comp_dict = get_mt_computation_dict()

    # Computing Greens functions for AoI
    Gx, Gy, Gz = multicomp_Greens_Pwave(nxyz=[nx_aoi, ny_aoi, nz_aoi],
                                        nr=nr,
                                        gamma_sourceangles=gamma_sourceangles_aoi,
                                        dist_table=dist_table_aoi,
                                        vel=mod,
                                        MT_comp_dict=MT_comp_dict,
                                        omega_p=1,
                                        )








.. GENERATED FROM PYTHON SOURCE LINES 193-194

Finally we can create our Kirchhoff-MT operator

.. GENERATED FROM PYTHON SOURCE LINES 194-211

.. code-block:: Python


    Mstack_Op = multicomp_pwave_mtioperator(
        x=x[xsi:xfi],
        y=y[ysi:yfi],
        z=z[zsi:zfi],
        recs=recs,
        t=t,
        wav=wav,
        wavc=wavc,
        tt_table=tt_table_aoi,
        Gx=Gx,
        Gy=Gy,
        Gz=Gz,
        Ms_scaling = 1e6,
        engine='numba'
        )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Dot test passed, v^H(Opu)=-0.528712107955366 - u^H(Op^Hv)=-0.5287121079553664




.. GENERATED FROM PYTHON SOURCE LINES 212-215

Joint localisation and MT inversion
-----------------------------------
Finally, we are ready to invert our waveform data for the 6 MT kernels.

.. GENERATED FROM PYTHON SOURCE LINES 215-225

.. code-block:: Python


    # Dimensions of area of interest
    nxyz = [nx_aoi, ny_aoi, nz_aoi]

    # Adjoint
    mt_adj = adjoint_mtmodelling(FD_data, Mstack_Op, nxyz)

    # Least-squares inversion
    mt_inv = lsqr_mtsolver(FD_data, Mstack_Op, nxyz)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

 
    LSQR            Least-squares solution of  Ax = b
    The matrix A has 214500 rows and 115506 columns
    damp = 0.00000000000000e+00   calc_var =        0
    atol = 0.00e+00                 conlim = 1.00e+08
    btol = 0.00e+00               iter_lim =       50
 
       Itn      x[0]       r1norm     r2norm   Compatible    LS      Norm A   Cond A
         0  0.00000e+00   6.828e+00  6.828e+00    1.0e+00  3.8e-03
         1 -1.31839e-01   4.205e+00  4.205e+00    6.2e-01  4.3e-01   3.3e-02  1.0e+00
         2 -1.10683e-01   2.804e+00  2.804e+00    4.1e-01  2.5e-01   4.0e-02  2.5e+00
         3  2.79791e-02   2.450e+00  2.450e+00    3.6e-01  1.8e-01   4.6e-02  3.8e+00
         4  2.11082e-01   2.188e+00  2.188e+00    3.2e-01  2.0e-01   5.1e-02  5.6e+00
         5  3.02030e-01   2.018e+00  2.018e+00    3.0e-01  8.0e-02   6.1e-02  7.9e+00
         6  2.37133e-01   1.877e+00  1.877e+00    2.7e-01  7.7e-02   6.4e-02  1.0e+01
         7  1.30798e-01   1.812e+00  1.812e+00    2.7e-01  8.9e-02   6.8e-02  1.2e+01
         8 -6.46784e-03   1.743e+00  1.743e+00    2.6e-01  6.1e-02   7.5e-02  1.5e+01
         9 -8.16319e-02   1.714e+00  1.714e+00    2.5e-01  3.7e-02   8.1e-02  1.7e+01
        10 -1.30471e-01   1.698e+00  1.698e+00    2.5e-01  4.3e-02   8.5e-02  1.9e+01
        40 -2.29418e+00   1.309e+00  1.309e+00    1.9e-01  9.9e-03   1.6e-01  1.8e+02
        41 -2.29036e+00   1.306e+00  1.306e+00    1.9e-01  8.8e-03   1.6e-01  1.8e+02
        42 -2.28336e+00   1.303e+00  1.303e+00    1.9e-01  7.6e-03   1.7e-01  1.9e+02
        43 -2.26788e+00   1.298e+00  1.298e+00    1.9e-01  8.3e-03   1.7e-01  2.0e+02
        44 -2.27188e+00   1.289e+00  1.289e+00    1.9e-01  9.5e-03   1.7e-01  2.1e+02
        45 -2.27904e+00   1.284e+00  1.284e+00    1.9e-01  1.1e-02   1.7e-01  2.1e+02
        46 -2.28354e+00   1.280e+00  1.280e+00    1.9e-01  9.8e-03   1.7e-01  2.2e+02
        47 -2.28524e+00   1.274e+00  1.274e+00    1.9e-01  1.0e-02   1.7e-01  2.3e+02
        48 -2.29217e+00   1.265e+00  1.265e+00    1.9e-01  7.9e-03   1.8e-01  2.5e+02
        49 -2.26644e+00   1.258e+00  1.258e+00    1.8e-01  1.2e-02   1.8e-01  2.6e+02
        50 -2.19205e+00   1.247e+00  1.247e+00    1.8e-01  9.0e-03   1.8e-01  2.7e+02
 
    LSQR finished
    The iteration limit has been reached                      
 
    istop =       7   r1norm = 1.2e+00   anorm = 1.8e-01   arnorm = 2.0e-03
    itn   =      50   r2norm = 1.2e+00   acond = 2.7e+02   xnorm  = 1.2e+03
 




.. GENERATED FROM PYTHON SOURCE LINES 226-227

Let's now extract both the expected location and MT source parameters

.. GENERATED FROM PYTHON SOURCE LINES 227-235

.. code-block:: Python


    exp_sloc, _ = expected_sloc_from_mtwi(mt_inv)
    print('Expected Source Location (AOI coord. ref.): \n', exp_sloc)
    mt_at_loc = get_mt_at_loc(mt_inv, [int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2])])
    print('MT at expected Source Location (full): \n', mt_at_loc)
    print('MT at expected Source Location (rounded): \n', np.round(mt_at_loc, decimals=2))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Expected Source Location (AOI coord. ref.): 
     [10.2  8.8 10.2]
    MT at expected Source Location (full): 
     (7.982835037415419, 10.287083558291586, 9.860573172342956, 0.08383296314613703, -12.558628342112446, -11.544952326165172)
    MT at expected Source Location (rounded): 
     [  7.98  10.29   9.86   0.08 -12.56 -11.54]




.. GENERATED FROM PYTHON SOURCE LINES 236-238

And finally we visualize the estimated kernels both from the adjoint and
inverse approaches.

.. GENERATED FROM PYTHON SOURCE LINES 238-253

.. code-block:: Python


    clim = 1
    fracspy.visualisation.eventimages.locimage3d(mt_adj[0], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_adj[1], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_adj[2], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_adj[3], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_adj[4], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_adj[5], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])

    fracspy.visualisation.eventimages.locimage3d(mt_inv[0], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_inv[1], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_inv[2], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_inv[3], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_inv[4], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])
    fracspy.visualisation.eventimages.locimage3d(mt_inv[5], int(exp_sloc[0]), int(exp_sloc[1]), int(exp_sloc[2]), clipval=[-clim, clim])



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_003.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_004.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_005.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_006.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_006.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_007.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_007.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_008.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_008.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_009.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_009.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_010.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_010.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_011.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_011.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_012.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_012.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_013.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_013.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_014.png
         :alt: MT WaveformInversion tutorial
         :srcset: /tutorials/images/sphx_glr_MT_WaveformInversion_tutorial_014.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/work/FraCSPy/FraCSPy/fracspy/visualisation/eventimages.py:12: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.
      fig.tight_layout()

    (<Figure size 800x800 with 5 Axes>, (<Axes: xlabel='x samples', ylabel='z samples'>, <Axes: xlabel='y samples'>, <Axes: ylabel='y samples'>))




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 48.544 seconds)


.. _sphx_glr_download_tutorials_MT_WaveformInversion_tutorial.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: MT_WaveformInversion_tutorial.ipynb <MT_WaveformInversion_tutorial.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: MT_WaveformInversion_tutorial.py <MT_WaveformInversion_tutorial.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: MT_WaveformInversion_tutorial.zip <MT_WaveformInversion_tutorial.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
